
# 2025/10/18
尝试完善Entity的移动，视口的适配。其中包裹：
1. 镜头Entity可以挂接到用户操作的实体上，然后随着用户操作实体，镜头Entity可以实现跟随。
2. 镜头及其关联的Transform，共同构建视口变换矩阵。对绘制的内容可以实现偏移。

上面这些都没有做。
全在折腾调试器了：
* 从main分支拉去的Love引擎在本地编译完成，CMake部分的编译配置搞了很久，OpenAL-Soft这个音频库在windows上的编译检查
存在很多问题
* local lua debugger没有办法在运行过程中添加断点。

目前这套逻辑能够绘制内容了，也能够响应键盘输入。但是响应的逻辑有问题，需要临时中断检查异常的原因。


# 2025/10/19
lua调试器问题：无法随时下断点的问题，是因为lldebugger这一套就不支持。
这个插件提供了两套内容，一套是Lua上运行的调试器，用来和Lua自己的debug接口打交道。另外一套是一个服务器，用来发送调试指令以及接收来自Lua调试器的数据。

它“下断点”的方式是，要求Lua调试器自己进入了暂停状态，然后它才会尝试去读取服务器发送过来的命令。而正式运行的过程中，它不会主动进入暂停状态，因此服务器发再多的命令，Lua调试器都不会响应。自然也就不能在运行时下任何断点。

修改的方式不是没有，就是在Love的Tick过程中，让Lua调试器主动检查有没有来自服务器的命令，有就暂停。但是lldebugger没有这套接口，而且时序也要重新整理。算了。

总之，要下新断点，要先让Lua暂停，即主动触发一个断点。然后才能进一步操作。

以上内容在AI Agent模式的协助下，分析得很顺利！

目前能够用键盘来控制角色移动了。但是角色一直位于屏幕的左上角。

# 2025/10/25
试着实现一下Entity的行为模式。

关于ECS的思考：
目前遇到的阻碍是，ECS模式在需要实现大量定制化的游戏逻辑的时候存在矛盾。因为个体的Entity有自己的独立的逻辑。假如还是要求对应的Component + System的设计，势必会变成100个不同行为的Entity出现100个对应的Component和System。可预见的这部分内容会不断膨胀。

一个对他们进行归纳的方式是，将他们都看作是“行为”组件，然后对应“行为”系统来对组件进行驱动。

对“行为”组件，有考虑过：
1. 单独的一个FSM + 若干自定义的节点的方式，来实现对“行为”的定义。
优点：抽象完节点之后，可以方便通过可视化的方式来组合更多的“行为”
缺点：运行逻辑不够直观。除非保证整套设计十分的稳定，否则调试起来将会非常麻烦
> 有点类似UE的蓝图了。
> 所谓节点，也是对指定Entity的某个组件的访问
2. 简单粗暴，直接上对应的脚本来定义一种完整的行为。就是“行为”本身作为“行为”组件的一个属性。
优点：直观
缺点：本质上还是100个Component + 100个System的设计。有点“偷换概念”的意思。
其实到这里已经很明朗了，假如将100 -> 1，那就是要设计一个超级System，它需要访问所有的Component。


当然也可以在这里考虑，再继续细分这个超级System。比方说A行为和B行为，它们不会同时出现，就可以再构建一个子System。这个思考的过程，无非就是在"排成一条线"和"排成一个点"之间反复平衡而已。

能不能将组件，分为Gameplay专属组件，以及非Gameplay组件呢？目的是避免一个超级System的出现，以及将它作为System的细分标准。比方说Gameplay相关逻辑的System，它可以访问所有的Gameplay组件，但是只会访问有限的几个非Gameplay组件。

但无论如何设计，最终都需要让“行为的状态”和“行为的逻辑分开”。

问题：你要怎么定义一个实体的行为呢？假设这个行为是：环绕某个Entity进行旋转

# 2025/10/26
尝试统一了整个世界的单位为米。
尝试校正了摄像机的view/proj矩阵，以及Drawable组件的绘制变换。

# 2025/10/27
暂时先将DebugTileTexture挂在Camera组件下，保证一直填充背景。

TODO: 可以平铺整个画面的背景图实现。不是现在这个DebugTileTexture，因为还要考虑Tilling的连续性
TODO: Entity带缩放的情况，以及带旋转的情况，都没有测试过的，暂时不知道正确性

# 2025/10/29
有个问题，现在的TransformCMP，要准确获取它的世界变换，就必须要往父节点进行遍历
只有知道父节点们的所有变换，才能知道自己的实际状态。

换句话说，一个get方法，可能会触发一系列的Transform更新？

懒更新呢？就是对Entity的TransformCMP设置了，但是不会立即更新。只有真正进行get的时候，才会开始回溯自己的各个父节点。假如父节点之前被set过，那就要开始重新计算。换言之，假如对一个TransformCMP进行get，需要回溯它的所有的父节点，确保所有父节点都不需要计算，这个时候才能获得准确的World。


# 设计

女主角，斧头，像素风，能够凸显角色动作(动态)
随机增益Buff，时间回溯，重力控制，
只有一个Boss必须打，其它都允许逃课，Boss可以追击或突然刷出，
即死机制对Boss同样适用

# 20205/11/02
TransformCMP是Gameplay控制的位置组件。PhysicCMP内部也有自己的位置信息。PhysicCMP中用的是World坐标系，TransformCMP中用的是Local/World。

# 2026/01/15
PhysicCMP以及PhysicSys能够接通了，也能够运行了。但因为Love2d默认了所有的脚本运算坐标系都是像素，它内部假定了30像素为1米给到Box2d。而我的脚本自己增加像素 -> 米的运算，因此需要在引擎一侧将30像素1米的缩放去掉。(不能再直接使用官方引擎了)。否则实际发生碰撞的位置会出错！


# 2026/01/18
更新关于“重力控制”的想法：
1. 重力井：场景中单点产生一个重力集中区，类似将周围的内容往中间吸引。同时，重力井范围内的时间流速变慢
> 像AI说的那样，可以用来控制一些特殊的开关。比方说小怪踩着一个阀门2s才能打开的机关，通过用重力井的方式，强行让
小怪留下，并且小怪的2s和主角的不一致
2. 加大重力力度：相当于让角色进入子弹时间
3. 修改重力方向
“重力控制”和“时间回溯”是互斥的。现在的物理暂时没有支持“时间回溯”的理论，时间的流速可以被重力改变，但是流向不行。所以，一旦使用了重力控制，时间回溯的锚点将会失效。时间回溯不能和重力控制同时起效

问题：
~~物理模拟对“时间回溯”的兼容性，即Snapshot只是有限的若干连续切片，但是用户可以回溯到允许的时间范围内的任意时刻。对于非Snapshot的时刻，物理状态(Box2d)应该怎么计算？目前这个是没有做的！~~

物理属性目前强行对Transform以及速度进行了插值，暂时没有看到有显著异常

# 2026/01/21

下一个Demo：
用户给小球施加力，然后开始物理演算。用户在任意时间点进行时间回溯
- ~~镜头应该屏蔽掉和主角关联的旋转属性~~
- 增加更多的可回溯物体以测试整体效果
- 回溯时候假如发生了Entity的变化，会怎么样？
- ~~动画组件也应该能够回溯~~
- ~~并不是所有Entity都需要回溯，比方说固定的地面、墙体之类的~~
- ~~主角等部分关键角色的物理碰撞应该屏蔽旋转分量，避免一场的旋转~~
- ~~回溯的过程应该加速进行~~

再下一步

- 增加触发器功能
- 场景以及Entity的组织方式需要修改。比方说，独立的配置文件描述这个场景的Entity情况
- Entity身上需要开始能够挂接更多自定义的Gameplay逻辑了。比方说，不同触发器身上会添加不同的逻辑。这个怎么管理？