
# 2025/10/18
尝试完善Entity的移动，视口的适配。其中包裹：
1. 镜头Entity可以挂接到用户操作的实体上，然后随着用户操作实体，镜头Entity可以实现跟随。
2. 镜头及其关联的Transform，共同构建视口变换矩阵。对绘制的内容可以实现偏移。

上面这些都没有做。
全在折腾调试器了：
* 从main分支拉去的Love引擎在本地编译完成，CMake部分的编译配置搞了很久，OpenAL-Soft这个音频库在windows上的编译检查
存在很多问题
* local lua debugger没有办法在运行过程中添加断点。

目前这套逻辑能够绘制内容了，也能够响应键盘输入。但是响应的逻辑有问题，需要临时中断检查异常的原因。


# 2025/10/19
lua调试器问题：无法随时下断点的问题，是因为lldebugger这一套就不支持。
这个插件提供了两套内容，一套是Lua上运行的调试器，用来和Lua自己的debug接口打交道。另外一套是一个服务器，用来发送调试指令以及接收来自Lua调试器的数据。

它“下断点”的方式是，要求Lua调试器自己进入了暂停状态，然后它才会尝试去读取服务器发送过来的命令。而正式运行的过程中，它不会主动进入暂停状态，因此服务器发再多的命令，Lua调试器都不会响应。自然也就不能在运行时下任何断点。

修改的方式不是没有，就是在Love的Tick过程中，让Lua调试器主动检查有没有来自服务器的命令，有就暂停。但是lldebugger没有这套接口，而且时序也要重新整理。算了。

总之，要下新断点，要先让Lua暂停，即主动触发一个断点。然后才能进一步操作。

以上内容在AI Agent模式的协助下，分析得很顺利！

目前能够用键盘来控制角色移动了。但是角色一直位于屏幕的左上角。

# 2025/10/25
试着实现一下Entity的行为模式。

关于ECS的思考：
目前遇到的阻碍是，ECS模式在需要实现大量定制化的游戏逻辑的时候存在矛盾。因为个体的Entity有自己的独立的逻辑。假如还是要求对应的Component + System的设计，势必会变成100个不同行为的Entity出现100个对应的Component和System。可预见的这部分内容会不断膨胀。

一个对他们进行归纳的方式是，将他们都看作是“行为”组件，然后对应“行为”系统来对组件进行驱动。

对“行为”组件，有考虑过：
1. 单独的一个FSM + 若干自定义的节点的方式，来实现对“行为”的定义。
优点：抽象完节点之后，可以方便通过可视化的方式来组合更多的“行为”
缺点：运行逻辑不够直观。除非保证整套设计十分的稳定，否则调试起来将会非常麻烦
> 有点类似UE的蓝图了。
> 所谓节点，也是对指定Entity的某个组件的访问
2. 简单粗暴，直接上对应的脚本来定义一种完整的行为。就是“行为”本身作为“行为”组件的一个属性。
优点：直观
缺点：本质上还是100个Component + 100个System的设计。有点“偷换概念”的意思。
其实到这里已经很明朗了，假如将100 -> 1，那就是要设计一个超级System，它需要访问所有的Component。


当然也可以在这里考虑，再继续细分这个超级System。比方说A行为和B行为，它们不会同时出现，就可以再构建一个子System。这个思考的过程，无非就是在"排成一条线"和"排成一个点"之间反复平衡而已。

能不能将组件，分为Gameplay专属组件，以及非Gameplay组件呢？目的是避免一个超级System的出现，以及将它作为System的细分标准。比方说Gameplay相关逻辑的System，它可以访问所有的Gameplay组件，但是只会访问有限的几个非Gameplay组件。

但无论如何设计，最终都需要让“行为的状态”和“行为的逻辑分开”。

问题：你要怎么定义一个实体的行为呢？假设这个行为是：环绕某个Entity进行旋转
